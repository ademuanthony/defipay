// Code generated by SQLBoiler 4.7.1 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Account is an object representing the database table.
type Account struct {
	ID                 string      `boil:"id" json:"id" toml:"id" yaml:"id"`
	Username           string      `boil:"username" json:"username" toml:"username" yaml:"username"`
	Password           string      `boil:"password" json:"password" toml:"password" yaml:"password"`
	CreatedAt          int64       `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	FirstName          string      `boil:"first_name" json:"first_name" toml:"first_name" yaml:"first_name"`
	LastName           string      `boil:"last_name" json:"last_name" toml:"last_name" yaml:"last_name"`
	ReferralID         null.String `boil:"referral_id" json:"referral_id,omitempty" toml:"referral_id" yaml:"referral_id,omitempty"`
	WithdrawalAddresss string      `boil:"withdrawal_addresss" json:"withdrawal_addresss" toml:"withdrawal_addresss" yaml:"withdrawal_addresss"`
	Balance            int64       `boil:"balance" json:"balance" toml:"balance" yaml:"balance"`
	Principal          int64       `boil:"principal" json:"principal" toml:"principal" yaml:"principal"`
	Email              string      `boil:"email" json:"email" toml:"email" yaml:"email"`
	PhoneNumber        string      `boil:"phone_number" json:"phone_number" toml:"phone_number" yaml:"phone_number"`
	MaturedPrincipal   int64       `boil:"matured_principal" json:"matured_principal" toml:"matured_principal" yaml:"matured_principal"`
	ReferralID2        null.String `boil:"referral_id_2" json:"referral_id_2,omitempty" toml:"referral_id_2" yaml:"referral_id_2,omitempty"`
	ReferralID3        null.String `boil:"referral_id_3" json:"referral_id_3,omitempty" toml:"referral_id_3" yaml:"referral_id_3,omitempty"`
	Role               null.Int    `boil:"role" json:"role,omitempty" toml:"role" yaml:"role,omitempty"`

	R *accountR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L accountL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var AccountColumns = struct {
	ID                 string
	Username           string
	Password           string
	CreatedAt          string
	FirstName          string
	LastName           string
	ReferralID         string
	WithdrawalAddresss string
	Balance            string
	Principal          string
	Email              string
	PhoneNumber        string
	MaturedPrincipal   string
	ReferralID2        string
	ReferralID3        string
	Role               string
}{
	ID:                 "id",
	Username:           "username",
	Password:           "password",
	CreatedAt:          "created_at",
	FirstName:          "first_name",
	LastName:           "last_name",
	ReferralID:         "referral_id",
	WithdrawalAddresss: "withdrawal_addresss",
	Balance:            "balance",
	Principal:          "principal",
	Email:              "email",
	PhoneNumber:        "phone_number",
	MaturedPrincipal:   "matured_principal",
	ReferralID2:        "referral_id_2",
	ReferralID3:        "referral_id_3",
	Role:               "role",
}

var AccountTableColumns = struct {
	ID                 string
	Username           string
	Password           string
	CreatedAt          string
	FirstName          string
	LastName           string
	ReferralID         string
	WithdrawalAddresss string
	Balance            string
	Principal          string
	Email              string
	PhoneNumber        string
	MaturedPrincipal   string
	ReferralID2        string
	ReferralID3        string
	Role               string
}{
	ID:                 "account.id",
	Username:           "account.username",
	Password:           "account.password",
	CreatedAt:          "account.created_at",
	FirstName:          "account.first_name",
	LastName:           "account.last_name",
	ReferralID:         "account.referral_id",
	WithdrawalAddresss: "account.withdrawal_addresss",
	Balance:            "account.balance",
	Principal:          "account.principal",
	Email:              "account.email",
	PhoneNumber:        "account.phone_number",
	MaturedPrincipal:   "account.matured_principal",
	ReferralID2:        "account.referral_id_2",
	ReferralID3:        "account.referral_id_3",
	Role:               "account.role",
}

// Generated where

type whereHelperstring struct{ field string }

func (w whereHelperstring) EQ(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperstring) NEQ(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperstring) LT(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperstring) LTE(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperstring) GT(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperstring) GTE(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperstring) IN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperstring) NIN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelperint64 struct{ field string }

func (w whereHelperint64) EQ(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint64) NEQ(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint64) LT(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint64) LTE(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint64) GT(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint64) GTE(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint64) IN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint64) NIN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpernull_String struct{ field string }

func (w whereHelpernull_String) EQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_String) NEQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_String) LT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_String) LTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_String) GT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_String) GTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_String) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_String) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelpernull_Int struct{ field string }

func (w whereHelpernull_Int) EQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int) NEQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int) LT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int) LTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int) GT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int) GTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_Int) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var AccountWhere = struct {
	ID                 whereHelperstring
	Username           whereHelperstring
	Password           whereHelperstring
	CreatedAt          whereHelperint64
	FirstName          whereHelperstring
	LastName           whereHelperstring
	ReferralID         whereHelpernull_String
	WithdrawalAddresss whereHelperstring
	Balance            whereHelperint64
	Principal          whereHelperint64
	Email              whereHelperstring
	PhoneNumber        whereHelperstring
	MaturedPrincipal   whereHelperint64
	ReferralID2        whereHelpernull_String
	ReferralID3        whereHelpernull_String
	Role               whereHelpernull_Int
}{
	ID:                 whereHelperstring{field: "\"account\".\"id\""},
	Username:           whereHelperstring{field: "\"account\".\"username\""},
	Password:           whereHelperstring{field: "\"account\".\"password\""},
	CreatedAt:          whereHelperint64{field: "\"account\".\"created_at\""},
	FirstName:          whereHelperstring{field: "\"account\".\"first_name\""},
	LastName:           whereHelperstring{field: "\"account\".\"last_name\""},
	ReferralID:         whereHelpernull_String{field: "\"account\".\"referral_id\""},
	WithdrawalAddresss: whereHelperstring{field: "\"account\".\"withdrawal_addresss\""},
	Balance:            whereHelperint64{field: "\"account\".\"balance\""},
	Principal:          whereHelperint64{field: "\"account\".\"principal\""},
	Email:              whereHelperstring{field: "\"account\".\"email\""},
	PhoneNumber:        whereHelperstring{field: "\"account\".\"phone_number\""},
	MaturedPrincipal:   whereHelperint64{field: "\"account\".\"matured_principal\""},
	ReferralID2:        whereHelpernull_String{field: "\"account\".\"referral_id_2\""},
	ReferralID3:        whereHelpernull_String{field: "\"account\".\"referral_id_3\""},
	Role:               whereHelpernull_Int{field: "\"account\".\"role\""},
}

// AccountRels is where relationship names are stored.
var AccountRels = struct {
	AccountTransactions        string
	DailyEarnings              string
	Deposits                   string
	Investments                string
	Notifications              string
	ReferralPayouts            string
	FromAccountReferralPayouts string
	Subscriptions              string
	Trades                     string
	TradeSchedules             string
	ReceiverTransfers          string
	SenderTransfers            string
	Wallets                    string
	Withdrawals                string
}{
	AccountTransactions:        "AccountTransactions",
	DailyEarnings:              "DailyEarnings",
	Deposits:                   "Deposits",
	Investments:                "Investments",
	Notifications:              "Notifications",
	ReferralPayouts:            "ReferralPayouts",
	FromAccountReferralPayouts: "FromAccountReferralPayouts",
	Subscriptions:              "Subscriptions",
	Trades:                     "Trades",
	TradeSchedules:             "TradeSchedules",
	ReceiverTransfers:          "ReceiverTransfers",
	SenderTransfers:            "SenderTransfers",
	Wallets:                    "Wallets",
	Withdrawals:                "Withdrawals",
}

// accountR is where relationships are stored.
type accountR struct {
	AccountTransactions        AccountTransactionSlice `boil:"AccountTransactions" json:"AccountTransactions" toml:"AccountTransactions" yaml:"AccountTransactions"`
	DailyEarnings              DailyEarningSlice       `boil:"DailyEarnings" json:"DailyEarnings" toml:"DailyEarnings" yaml:"DailyEarnings"`
	Deposits                   DepositSlice            `boil:"Deposits" json:"Deposits" toml:"Deposits" yaml:"Deposits"`
	Investments                InvestmentSlice         `boil:"Investments" json:"Investments" toml:"Investments" yaml:"Investments"`
	Notifications              NotificationSlice       `boil:"Notifications" json:"Notifications" toml:"Notifications" yaml:"Notifications"`
	ReferralPayouts            ReferralPayoutSlice     `boil:"ReferralPayouts" json:"ReferralPayouts" toml:"ReferralPayouts" yaml:"ReferralPayouts"`
	FromAccountReferralPayouts ReferralPayoutSlice     `boil:"FromAccountReferralPayouts" json:"FromAccountReferralPayouts" toml:"FromAccountReferralPayouts" yaml:"FromAccountReferralPayouts"`
	Subscriptions              SubscriptionSlice       `boil:"Subscriptions" json:"Subscriptions" toml:"Subscriptions" yaml:"Subscriptions"`
	Trades                     TradeSlice              `boil:"Trades" json:"Trades" toml:"Trades" yaml:"Trades"`
	TradeSchedules             TradeScheduleSlice      `boil:"TradeSchedules" json:"TradeSchedules" toml:"TradeSchedules" yaml:"TradeSchedules"`
	ReceiverTransfers          TransferSlice           `boil:"ReceiverTransfers" json:"ReceiverTransfers" toml:"ReceiverTransfers" yaml:"ReceiverTransfers"`
	SenderTransfers            TransferSlice           `boil:"SenderTransfers" json:"SenderTransfers" toml:"SenderTransfers" yaml:"SenderTransfers"`
	Wallets                    WalletSlice             `boil:"Wallets" json:"Wallets" toml:"Wallets" yaml:"Wallets"`
	Withdrawals                WithdrawalSlice         `boil:"Withdrawals" json:"Withdrawals" toml:"Withdrawals" yaml:"Withdrawals"`
}

// NewStruct creates a new relationship struct
func (*accountR) NewStruct() *accountR {
	return &accountR{}
}

// accountL is where Load methods for each relationship are stored.
type accountL struct{}

var (
	accountAllColumns            = []string{"id", "username", "password", "created_at", "first_name", "last_name", "referral_id", "withdrawal_addresss", "balance", "principal", "email", "phone_number", "matured_principal", "referral_id_2", "referral_id_3", "role"}
	accountColumnsWithoutDefault = []string{"id", "username", "password", "created_at", "first_name", "last_name", "referral_id", "withdrawal_addresss", "balance", "principal", "email"}
	accountColumnsWithDefault    = []string{"phone_number", "matured_principal", "referral_id_2", "referral_id_3", "role"}
	accountPrimaryKeyColumns     = []string{"id"}
)

type (
	// AccountSlice is an alias for a slice of pointers to Account.
	// This should almost always be used instead of []Account.
	AccountSlice []*Account

	accountQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	accountType                 = reflect.TypeOf(&Account{})
	accountMapping              = queries.MakeStructMapping(accountType)
	accountPrimaryKeyMapping, _ = queries.BindMapping(accountType, accountMapping, accountPrimaryKeyColumns)
	accountInsertCacheMut       sync.RWMutex
	accountInsertCache          = make(map[string]insertCache)
	accountUpdateCacheMut       sync.RWMutex
	accountUpdateCache          = make(map[string]updateCache)
	accountUpsertCacheMut       sync.RWMutex
	accountUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single account record from the query.
func (q accountQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Account, error) {
	o := &Account{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for account")
	}

	return o, nil
}

// All returns all Account records from the query.
func (q accountQuery) All(ctx context.Context, exec boil.ContextExecutor) (AccountSlice, error) {
	var o []*Account

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Account slice")
	}

	return o, nil
}

// Count returns the count of all Account records in the query.
func (q accountQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count account rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q accountQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if account exists")
	}

	return count > 0, nil
}

// AccountTransactions retrieves all the account_transaction's AccountTransactions with an executor.
func (o *Account) AccountTransactions(mods ...qm.QueryMod) accountTransactionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"account_transaction\".\"account_id\"=?", o.ID),
	)

	query := AccountTransactions(queryMods...)
	queries.SetFrom(query.Query, "\"account_transaction\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"account_transaction\".*"})
	}

	return query
}

// DailyEarnings retrieves all the daily_earning's DailyEarnings with an executor.
func (o *Account) DailyEarnings(mods ...qm.QueryMod) dailyEarningQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"daily_earning\".\"account_id\"=?", o.ID),
	)

	query := DailyEarnings(queryMods...)
	queries.SetFrom(query.Query, "\"daily_earning\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"daily_earning\".*"})
	}

	return query
}

// Deposits retrieves all the deposit's Deposits with an executor.
func (o *Account) Deposits(mods ...qm.QueryMod) depositQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"deposit\".\"account_id\"=?", o.ID),
	)

	query := Deposits(queryMods...)
	queries.SetFrom(query.Query, "\"deposit\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"deposit\".*"})
	}

	return query
}

// Investments retrieves all the investment's Investments with an executor.
func (o *Account) Investments(mods ...qm.QueryMod) investmentQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"investment\".\"account_id\"=?", o.ID),
	)

	query := Investments(queryMods...)
	queries.SetFrom(query.Query, "\"investment\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"investment\".*"})
	}

	return query
}

// Notifications retrieves all the notification's Notifications with an executor.
func (o *Account) Notifications(mods ...qm.QueryMod) notificationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"notification\".\"account_id\"=?", o.ID),
	)

	query := Notifications(queryMods...)
	queries.SetFrom(query.Query, "\"notification\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"notification\".*"})
	}

	return query
}

// ReferralPayouts retrieves all the referral_payout's ReferralPayouts with an executor.
func (o *Account) ReferralPayouts(mods ...qm.QueryMod) referralPayoutQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"referral_payout\".\"account_id\"=?", o.ID),
	)

	query := ReferralPayouts(queryMods...)
	queries.SetFrom(query.Query, "\"referral_payout\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"referral_payout\".*"})
	}

	return query
}

// FromAccountReferralPayouts retrieves all the referral_payout's ReferralPayouts with an executor via from_account_id column.
func (o *Account) FromAccountReferralPayouts(mods ...qm.QueryMod) referralPayoutQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"referral_payout\".\"from_account_id\"=?", o.ID),
	)

	query := ReferralPayouts(queryMods...)
	queries.SetFrom(query.Query, "\"referral_payout\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"referral_payout\".*"})
	}

	return query
}

// Subscriptions retrieves all the subscription's Subscriptions with an executor.
func (o *Account) Subscriptions(mods ...qm.QueryMod) subscriptionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"subscription\".\"account_id\"=?", o.ID),
	)

	query := Subscriptions(queryMods...)
	queries.SetFrom(query.Query, "\"subscription\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"subscription\".*"})
	}

	return query
}

// Trades retrieves all the trade's Trades with an executor.
func (o *Account) Trades(mods ...qm.QueryMod) tradeQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"trade\".\"account_id\"=?", o.ID),
	)

	query := Trades(queryMods...)
	queries.SetFrom(query.Query, "\"trade\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"trade\".*"})
	}

	return query
}

// TradeSchedules retrieves all the trade_schedule's TradeSchedules with an executor.
func (o *Account) TradeSchedules(mods ...qm.QueryMod) tradeScheduleQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"trade_schedule\".\"account_id\"=?", o.ID),
	)

	query := TradeSchedules(queryMods...)
	queries.SetFrom(query.Query, "\"trade_schedule\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"trade_schedule\".*"})
	}

	return query
}

// ReceiverTransfers retrieves all the transfer's Transfers with an executor via receiver_id column.
func (o *Account) ReceiverTransfers(mods ...qm.QueryMod) transferQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"transfer\".\"receiver_id\"=?", o.ID),
	)

	query := Transfers(queryMods...)
	queries.SetFrom(query.Query, "\"transfer\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"transfer\".*"})
	}

	return query
}

// SenderTransfers retrieves all the transfer's Transfers with an executor via sender_id column.
func (o *Account) SenderTransfers(mods ...qm.QueryMod) transferQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"transfer\".\"sender_id\"=?", o.ID),
	)

	query := Transfers(queryMods...)
	queries.SetFrom(query.Query, "\"transfer\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"transfer\".*"})
	}

	return query
}

// Wallets retrieves all the wallet's Wallets with an executor.
func (o *Account) Wallets(mods ...qm.QueryMod) walletQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"wallet\".\"account_id\"=?", o.ID),
	)

	query := Wallets(queryMods...)
	queries.SetFrom(query.Query, "\"wallet\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"wallet\".*"})
	}

	return query
}

// Withdrawals retrieves all the withdrawal's Withdrawals with an executor.
func (o *Account) Withdrawals(mods ...qm.QueryMod) withdrawalQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"withdrawal\".\"account_id\"=?", o.ID),
	)

	query := Withdrawals(queryMods...)
	queries.SetFrom(query.Query, "\"withdrawal\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"withdrawal\".*"})
	}

	return query
}

// LoadAccountTransactions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadAccountTransactions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`account_transaction`),
		qm.WhereIn(`account_transaction.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load account_transaction")
	}

	var resultSlice []*AccountTransaction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice account_transaction")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on account_transaction")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for account_transaction")
	}

	if singular {
		object.R.AccountTransactions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &accountTransactionR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.AccountTransactions = append(local.R.AccountTransactions, foreign)
				if foreign.R == nil {
					foreign.R = &accountTransactionR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadDailyEarnings allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadDailyEarnings(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`daily_earning`),
		qm.WhereIn(`daily_earning.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load daily_earning")
	}

	var resultSlice []*DailyEarning
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice daily_earning")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on daily_earning")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for daily_earning")
	}

	if singular {
		object.R.DailyEarnings = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dailyEarningR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.DailyEarnings = append(local.R.DailyEarnings, foreign)
				if foreign.R == nil {
					foreign.R = &dailyEarningR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadDeposits allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadDeposits(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`deposit`),
		qm.WhereIn(`deposit.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load deposit")
	}

	var resultSlice []*Deposit
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice deposit")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on deposit")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for deposit")
	}

	if singular {
		object.R.Deposits = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &depositR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.Deposits = append(local.R.Deposits, foreign)
				if foreign.R == nil {
					foreign.R = &depositR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadInvestments allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadInvestments(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`investment`),
		qm.WhereIn(`investment.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load investment")
	}

	var resultSlice []*Investment
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice investment")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on investment")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for investment")
	}

	if singular {
		object.R.Investments = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &investmentR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.Investments = append(local.R.Investments, foreign)
				if foreign.R == nil {
					foreign.R = &investmentR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadNotifications allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadNotifications(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`notification`),
		qm.WhereIn(`notification.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load notification")
	}

	var resultSlice []*Notification
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice notification")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on notification")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for notification")
	}

	if singular {
		object.R.Notifications = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &notificationR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.Notifications = append(local.R.Notifications, foreign)
				if foreign.R == nil {
					foreign.R = &notificationR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadReferralPayouts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadReferralPayouts(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`referral_payout`),
		qm.WhereIn(`referral_payout.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load referral_payout")
	}

	var resultSlice []*ReferralPayout
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice referral_payout")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on referral_payout")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for referral_payout")
	}

	if singular {
		object.R.ReferralPayouts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &referralPayoutR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.ReferralPayouts = append(local.R.ReferralPayouts, foreign)
				if foreign.R == nil {
					foreign.R = &referralPayoutR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadFromAccountReferralPayouts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadFromAccountReferralPayouts(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`referral_payout`),
		qm.WhereIn(`referral_payout.from_account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load referral_payout")
	}

	var resultSlice []*ReferralPayout
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice referral_payout")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on referral_payout")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for referral_payout")
	}

	if singular {
		object.R.FromAccountReferralPayouts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &referralPayoutR{}
			}
			foreign.R.FromAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FromAccountID {
				local.R.FromAccountReferralPayouts = append(local.R.FromAccountReferralPayouts, foreign)
				if foreign.R == nil {
					foreign.R = &referralPayoutR{}
				}
				foreign.R.FromAccount = local
				break
			}
		}
	}

	return nil
}

// LoadSubscriptions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadSubscriptions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`subscription`),
		qm.WhereIn(`subscription.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load subscription")
	}

	var resultSlice []*Subscription
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice subscription")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on subscription")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for subscription")
	}

	if singular {
		object.R.Subscriptions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &subscriptionR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.Subscriptions = append(local.R.Subscriptions, foreign)
				if foreign.R == nil {
					foreign.R = &subscriptionR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadTrades allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadTrades(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`trade`),
		qm.WhereIn(`trade.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load trade")
	}

	var resultSlice []*Trade
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice trade")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on trade")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for trade")
	}

	if singular {
		object.R.Trades = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tradeR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.Trades = append(local.R.Trades, foreign)
				if foreign.R == nil {
					foreign.R = &tradeR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadTradeSchedules allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadTradeSchedules(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`trade_schedule`),
		qm.WhereIn(`trade_schedule.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load trade_schedule")
	}

	var resultSlice []*TradeSchedule
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice trade_schedule")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on trade_schedule")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for trade_schedule")
	}

	if singular {
		object.R.TradeSchedules = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &tradeScheduleR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.TradeSchedules = append(local.R.TradeSchedules, foreign)
				if foreign.R == nil {
					foreign.R = &tradeScheduleR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadReceiverTransfers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadReceiverTransfers(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`transfer`),
		qm.WhereIn(`transfer.receiver_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load transfer")
	}

	var resultSlice []*Transfer
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice transfer")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on transfer")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for transfer")
	}

	if singular {
		object.R.ReceiverTransfers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &transferR{}
			}
			foreign.R.Receiver = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ReceiverID {
				local.R.ReceiverTransfers = append(local.R.ReceiverTransfers, foreign)
				if foreign.R == nil {
					foreign.R = &transferR{}
				}
				foreign.R.Receiver = local
				break
			}
		}
	}

	return nil
}

// LoadSenderTransfers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadSenderTransfers(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`transfer`),
		qm.WhereIn(`transfer.sender_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load transfer")
	}

	var resultSlice []*Transfer
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice transfer")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on transfer")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for transfer")
	}

	if singular {
		object.R.SenderTransfers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &transferR{}
			}
			foreign.R.Sender = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.SenderID {
				local.R.SenderTransfers = append(local.R.SenderTransfers, foreign)
				if foreign.R == nil {
					foreign.R = &transferR{}
				}
				foreign.R.Sender = local
				break
			}
		}
	}

	return nil
}

// LoadWallets allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadWallets(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`wallet`),
		qm.WhereIn(`wallet.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load wallet")
	}

	var resultSlice []*Wallet
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice wallet")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on wallet")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for wallet")
	}

	if singular {
		object.R.Wallets = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &walletR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.Wallets = append(local.R.Wallets, foreign)
				if foreign.R == nil {
					foreign.R = &walletR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// LoadWithdrawals allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (accountL) LoadWithdrawals(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAccount interface{}, mods queries.Applicator) error {
	var slice []*Account
	var object *Account

	if singular {
		object = maybeAccount.(*Account)
	} else {
		slice = *maybeAccount.(*[]*Account)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &accountR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &accountR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`withdrawal`),
		qm.WhereIn(`withdrawal.account_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load withdrawal")
	}

	var resultSlice []*Withdrawal
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice withdrawal")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on withdrawal")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for withdrawal")
	}

	if singular {
		object.R.Withdrawals = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &withdrawalR{}
			}
			foreign.R.Account = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AccountID {
				local.R.Withdrawals = append(local.R.Withdrawals, foreign)
				if foreign.R == nil {
					foreign.R = &withdrawalR{}
				}
				foreign.R.Account = local
				break
			}
		}
	}

	return nil
}

// AddAccountTransactions adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.AccountTransactions.
// Sets related.R.Account appropriately.
func (o *Account) AddAccountTransactions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AccountTransaction) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"account_transaction\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, accountTransactionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			AccountTransactions: related,
		}
	} else {
		o.R.AccountTransactions = append(o.R.AccountTransactions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &accountTransactionR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddDailyEarnings adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.DailyEarnings.
// Sets related.R.Account appropriately.
func (o *Account) AddDailyEarnings(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DailyEarning) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"daily_earning\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, dailyEarningPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			DailyEarnings: related,
		}
	} else {
		o.R.DailyEarnings = append(o.R.DailyEarnings, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dailyEarningR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddDeposits adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.Deposits.
// Sets related.R.Account appropriately.
func (o *Account) AddDeposits(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Deposit) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"deposit\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, depositPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			Deposits: related,
		}
	} else {
		o.R.Deposits = append(o.R.Deposits, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &depositR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddInvestments adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.Investments.
// Sets related.R.Account appropriately.
func (o *Account) AddInvestments(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Investment) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"investment\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, investmentPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			Investments: related,
		}
	} else {
		o.R.Investments = append(o.R.Investments, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &investmentR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddNotifications adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.Notifications.
// Sets related.R.Account appropriately.
func (o *Account) AddNotifications(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Notification) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"notification\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, notificationPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			Notifications: related,
		}
	} else {
		o.R.Notifications = append(o.R.Notifications, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &notificationR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddReferralPayouts adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.ReferralPayouts.
// Sets related.R.Account appropriately.
func (o *Account) AddReferralPayouts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ReferralPayout) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"referral_payout\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, referralPayoutPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			ReferralPayouts: related,
		}
	} else {
		o.R.ReferralPayouts = append(o.R.ReferralPayouts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &referralPayoutR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddFromAccountReferralPayouts adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.FromAccountReferralPayouts.
// Sets related.R.FromAccount appropriately.
func (o *Account) AddFromAccountReferralPayouts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ReferralPayout) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FromAccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"referral_payout\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"from_account_id"}),
				strmangle.WhereClause("\"", "\"", 2, referralPayoutPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FromAccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			FromAccountReferralPayouts: related,
		}
	} else {
		o.R.FromAccountReferralPayouts = append(o.R.FromAccountReferralPayouts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &referralPayoutR{
				FromAccount: o,
			}
		} else {
			rel.R.FromAccount = o
		}
	}
	return nil
}

// AddSubscriptions adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.Subscriptions.
// Sets related.R.Account appropriately.
func (o *Account) AddSubscriptions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Subscription) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"subscription\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, subscriptionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			Subscriptions: related,
		}
	} else {
		o.R.Subscriptions = append(o.R.Subscriptions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &subscriptionR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddTrades adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.Trades.
// Sets related.R.Account appropriately.
func (o *Account) AddTrades(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Trade) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"trade\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, tradePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			Trades: related,
		}
	} else {
		o.R.Trades = append(o.R.Trades, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tradeR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddTradeSchedules adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.TradeSchedules.
// Sets related.R.Account appropriately.
func (o *Account) AddTradeSchedules(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TradeSchedule) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"trade_schedule\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, tradeSchedulePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			TradeSchedules: related,
		}
	} else {
		o.R.TradeSchedules = append(o.R.TradeSchedules, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &tradeScheduleR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddReceiverTransfers adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.ReceiverTransfers.
// Sets related.R.Receiver appropriately.
func (o *Account) AddReceiverTransfers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Transfer) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ReceiverID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"transfer\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"receiver_id"}),
				strmangle.WhereClause("\"", "\"", 2, transferPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ReceiverID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			ReceiverTransfers: related,
		}
	} else {
		o.R.ReceiverTransfers = append(o.R.ReceiverTransfers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &transferR{
				Receiver: o,
			}
		} else {
			rel.R.Receiver = o
		}
	}
	return nil
}

// AddSenderTransfers adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.SenderTransfers.
// Sets related.R.Sender appropriately.
func (o *Account) AddSenderTransfers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Transfer) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.SenderID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"transfer\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"sender_id"}),
				strmangle.WhereClause("\"", "\"", 2, transferPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.SenderID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			SenderTransfers: related,
		}
	} else {
		o.R.SenderTransfers = append(o.R.SenderTransfers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &transferR{
				Sender: o,
			}
		} else {
			rel.R.Sender = o
		}
	}
	return nil
}

// AddWallets adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.Wallets.
// Sets related.R.Account appropriately.
func (o *Account) AddWallets(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Wallet) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"wallet\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, walletPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			Wallets: related,
		}
	} else {
		o.R.Wallets = append(o.R.Wallets, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &walletR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// AddWithdrawals adds the given related objects to the existing relationships
// of the account, optionally inserting them as new records.
// Appends related to o.R.Withdrawals.
// Sets related.R.Account appropriately.
func (o *Account) AddWithdrawals(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Withdrawal) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AccountID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"withdrawal\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
				strmangle.WhereClause("\"", "\"", 2, withdrawalPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AccountID = o.ID
		}
	}

	if o.R == nil {
		o.R = &accountR{
			Withdrawals: related,
		}
	} else {
		o.R.Withdrawals = append(o.R.Withdrawals, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &withdrawalR{
				Account: o,
			}
		} else {
			rel.R.Account = o
		}
	}
	return nil
}

// Accounts retrieves all the records using an executor.
func Accounts(mods ...qm.QueryMod) accountQuery {
	mods = append(mods, qm.From("\"account\""))
	return accountQuery{NewQuery(mods...)}
}

// FindAccount retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindAccount(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*Account, error) {
	accountObj := &Account{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"account\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, accountObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from account")
	}

	return accountObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Account) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no account provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(accountColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	accountInsertCacheMut.RLock()
	cache, cached := accountInsertCache[key]
	accountInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			accountAllColumns,
			accountColumnsWithDefault,
			accountColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(accountType, accountMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(accountType, accountMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"account\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"account\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into account")
	}

	if !cached {
		accountInsertCacheMut.Lock()
		accountInsertCache[key] = cache
		accountInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the Account.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Account) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	key := makeCacheKey(columns, nil)
	accountUpdateCacheMut.RLock()
	cache, cached := accountUpdateCache[key]
	accountUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			accountAllColumns,
			accountPrimaryKeyColumns,
		)

		if len(wl) == 0 {
			return 0, errors.New("models: unable to update account, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"account\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, accountPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(accountType, accountMapping, append(wl, accountPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update account row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for account")
	}

	if !cached {
		accountUpdateCacheMut.Lock()
		accountUpdateCache[key] = cache
		accountUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values.
func (q accountQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for account")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for account")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o AccountSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), accountPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"account\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, accountPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in account slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all account")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Account) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no account provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(accountColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	accountUpsertCacheMut.RLock()
	cache, cached := accountUpsertCache[key]
	accountUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			accountAllColumns,
			accountColumnsWithDefault,
			accountColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			accountAllColumns,
			accountPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert account, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(accountPrimaryKeyColumns))
			copy(conflict, accountPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"account\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(accountType, accountMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(accountType, accountMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert account")
	}

	if !cached {
		accountUpsertCacheMut.Lock()
		accountUpsertCache[key] = cache
		accountUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single Account record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Account) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Account provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), accountPrimaryKeyMapping)
	sql := "DELETE FROM \"account\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from account")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for account")
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q accountQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no accountQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from account")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for account")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o AccountSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), accountPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"account\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, accountPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from account slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for account")
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Account) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindAccount(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *AccountSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := AccountSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), accountPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"account\".* FROM \"account\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, accountPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in AccountSlice")
	}

	*o = slice

	return nil
}

// AccountExists checks if the Account row exists.
func AccountExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"account\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if account exists")
	}

	return exists, nil
}
